{"meta":{"title":"hcb的技术空间","subtitle":"","description":"","author":"hcb","url":"http://yoursite.com","root":"/"},"pages":[{"title":"文章分类","date":"2020-02-15T18:07:14.000Z","updated":"2020-02-15T15:10:28.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-02-15T18:04:42.000Z","updated":"2020-02-15T10:06:55.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"解决递归造成重复计算的这类问题","slug":"解决递归造成重复计算的这类问题","date":"2020-02-20T22:14:14.000Z","updated":"2020-02-21T18:01:41.000Z","comments":true,"path":"2020/02/21/解决递归造成重复计算的这类问题/","link":"","permalink":"http://yoursite.com/2020/02/21/%E8%A7%A3%E5%86%B3%E9%80%92%E5%BD%92%E9%80%A0%E6%88%90%E9%87%8D%E5%A4%8D%E8%AE%A1%E7%AE%97%E7%9A%84%E8%BF%99%E7%B1%BB%E9%97%AE%E9%A2%98/","excerpt":"","text":"示例一 斐波那契数列的N种解法 示例2 题目描述 给定一个数字，按照如下规则翻译成字符串：0 翻译成“a”，1 翻译成“b”... 25 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 bccfi，bwfi，bczi，mcfi，mzi。实现一个函数，用来计算一个数字有多少种不同的翻译方法。 解题思路 12345678910111213141516171819202122232425自上而下，从最大的问题开始，递归 ： 12258 / \\ b+2258 m+258 / \\ / \\ bc+258 bw+58 mc+58 mz+8 / \\ \\ \\ \\ bcc+58 bcz+8 bwf+8 mcf+8 mzi / \\ \\ \\ bccf+8 bczi bwfi mcfi / bccfi有很多子问题被多次计算，比如258被翻译成几种这个子问题就被计算了两次。自下而上，动态规划，从最小的问题开始 ：f(r)表示以r为开始（r最小取0）到最右端所组成的数字能够翻译成字符串的种数。对于长度为n的数字，f(n)=0,f(n-1)=1,求f(0)。递推公式为 f(r-2) = f(r-1)+g(r-2,r-1)*f(r)；其中，如果r-2，r-1能够翻译成字符，则g(r-2,r-1)=1，否则为0。因此，对于12258：f(5) = 0f(4) = 1f(3) = f(4)+0 = 1f(2) = f(3)+f(4) = 2f(1) = f(2)+f(3) = 3f(0) = f(1)+f(2) = 5 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.hcb.algorithm.chapter5;/** * 这个问题和斐波那契是一类问题,递归会造成重复计算的问题 */public class Sword46 &#123; // markdown 解法,该解法是把每次结果都保存起来,在本题中没有必要,因为只需要用到每个元素的前两个计算结果,但是该解法对于一般性的问题有借鉴意义 public static int numDecodings(String s) &#123; if (s == null || s.length() == 0) return 0; int n = s.length(); int[] dp = new int[n + 1]; dp[n] = 1; dp[n-1] = 1; for (int i = n-2; i &gt;= 0; i--) &#123; int num = Integer.valueOf(s.substring(i, i+2)); if (num &lt;= 25 &amp;&amp; num &gt;= 10)&#123; dp[i] = dp[i+1]+dp[i+2]; &#125;else &#123; dp[i] = dp[i+1]; &#125; &#125; return dp[0]; &#125; public static int getTranslationCount(int number)&#123; if(number&lt;0) return 0; return getTranslationCount(Integer.toString(number)); &#125; //动态规划，从右到左计算。 //f(r-2) = f(r-1)+g(r-2,r-1)*f(r); //如果r-2，r-1能够翻译成字符，则g(r-2,r-1)=1，否则为0 public static int getTranslationCount(String number) &#123; int f1 = 1,f2 = 1,g = 0; int temp; for(int i=number.length()-2;i&gt;=0;i--)&#123; if(Integer.parseInt(number.charAt(i)+\"\"+number.charAt(i+1))&lt;26 &amp;&amp; Integer.parseInt(number.charAt(i)+\"\"+number.charAt(i+1))&gt;=10) g = 1; else g = 0; temp = f2; f2 = f2+g*f1; f1 = temp; &#125; return f2; &#125; public static void main(String[] args)&#123; System.out.println(getTranslationCount(12258)); //5 System.out.println(numDecodings(\"12258\")); System.out.println(getTranslationCount(10258)); //5 System.out.println(numDecodings(\"10258\")); &#125;&#125; 示例3 题目描述 在一个 m*n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于 0）。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘 12341 10 3 812 2 9 65 7 4 113 7 16 5 礼物的最大价值为 1+12+5+7+7+16+5=53。 解题思路 为了避免重复计算,我们需要用迭代代替递归.那么从哪里开始迭代呢?对应两种思路. 此题有两种思路: distance(1,5)=1+max(distance(10,5),distance(12,5)) ,这种思路那么最先计算得到结果的是distance(11,5)和distance(16,5) ,也就是说,需要从5开始迭代. 如果我们按照常规思维,想从1开始迭代,那么我们需要另外一种思路.就是distance(1,5)=max(distance(1,11),distance(1,16))+5 ,这样,才会先开始计算distance(1,10)和distance(1,12) ,进而产生从1开始迭代的结果. 代码 12345678910111213public static int getMost(int[][] values) &#123; if (values == null || values.length == 0 || values[0].length == 0) return 0; int n = values[0].length; int[] dp = new int[n]; for (int[] value : values) &#123; dp[0] += value[0]; for (int i = 1; i &lt; n; i++) //dp[i]表示上面对应元素到1的最大值,dp[i-1]表示左边元素到1的最大值 dp[i] = Math.max(dp[i], dp[i - 1]) + value[i]; &#125; return dp[n - 1]; &#125; 递归解法 如果非要使用递归,可以在进入递归函数前,先判断该位置的值是否已经计算过,这样也能保证每个位置的值被计算1次. 123456789101112131415161718192021public static int getMost2(int[][] values)&#123; int[][] distances = new int[values.length][values[0].length]; int num = getMostRec(values,distances,0,0); return num; &#125; // 先进行判断,如果有值,说明计算过了,就不计算了 private static int getMostRec(int[][] values, int[][] distances,int startI,int startJ) &#123; if(startI == values.length-1 &amp;&amp; startJ == values[0].length-1)&#123; return values[startI][startJ]; &#125; if (startI == values.length-1) &#123; distances[startI][startJ] = values[startI][startJ] + (distances[startI][startJ+1] != 0?distances[startI][startJ+1]:getMostRec(values, distances, startI, startJ + 1)); &#125; else if (startJ == values[0].length-1) &#123; distances[startI][startJ] = values[startI][startJ] + (distances[startI+1][startJ] != 0?distances[startI+1][startJ]:getMostRec(values, distances, startI+1, startJ)); &#125; else &#123; distances[startI][startJ] = values[startI][startJ] + Math.max(distances[startI][startJ+1] != 0?distances[startI][startJ+1]:getMostRec(values, distances, startI, startJ + 1), distances[startI+1][startJ] != 0?distances[startI+1][startJ]:getMostRec(values, distances, startI+1, startJ)); &#125; return distances[startI][startJ]; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"递归","slug":"递归","permalink":"http://yoursite.com/tags/%E9%80%92%E5%BD%92/"}]},{"title":"红黑树节点插入的分析以及java实现","slug":"红黑树结点插入的分析以及java实现","date":"2020-02-18T23:55:31.000Z","updated":"2020-02-18T16:47:39.000Z","comments":true,"path":"2020/02/19/红黑树结点插入的分析以及java实现/","link":"","permalink":"http://yoursite.com/2020/02/19/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E7%82%B9%E6%8F%92%E5%85%A5%E7%9A%84%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8Ajava%E5%AE%9E%E7%8E%B0/","excerpt":"红黑树(Red-black tree)是二叉排序树(又名二叉搜索树,binary search tree)的一种,具备二叉排序树节点有序的特征.但是二叉排序树存在树倾斜的问题,极端情况下会造成O(N)的查找效率,红黑树能解决此问题,使树始终保持平衡. 特点 红黑树具备如下特点: 其每个节点要么是红色,要么是黑色; 其根节点和空的叶子节点(NIL)为黑色; 如果一个节点是红色的,那么它的子节点一定是黑色; 对于一个固定的节点,其到任意一个NIL的路径中,一定包含相等的黑色节点数. 以上特点确保其 一个节点到一个NIL的最长的路径不会超过其到另一个NIL的最短路径的2倍.因为根据上面3,4两点,其最短路径为路径上的节点都为黑色,最长路径为黑红交替.因此会有以上结论.","text":"红黑树(Red-black tree)是二叉排序树(又名二叉搜索树,binary search tree)的一种,具备二叉排序树节点有序的特征.但是二叉排序树存在树倾斜的问题,极端情况下会造成O(N)的查找效率,红黑树能解决此问题,使树始终保持平衡. 特点 红黑树具备如下特点: 其每个节点要么是红色,要么是黑色; 其根节点和空的叶子节点(NIL)为黑色; 如果一个节点是红色的,那么它的子节点一定是黑色; 对于一个固定的节点,其到任意一个NIL的路径中,一定包含相等的黑色节点数. 以上特点确保其 一个节点到一个NIL的最长的路径不会超过其到另一个NIL的最短路径的2倍.因为根据上面3,4两点,其最短路径为路径上的节点都为黑色,最长路径为黑红交替.因此会有以上结论. 操作 对一棵红黑树的一个节点,通常有以下操作,以及其对应的时间复杂度: 查找:O(lgN) 插入:O(lgN) 删除:O(lgN) 另外,我们需要记录节点颜色的额外O(N)的空间复杂度. 插入 在插入一个节点时,会造成红黑树特殊特性质的\"违反\",因此在插入节点时,需要进行额外的\"矫正\"操作. 左旋右旋 左旋和右旋作为矫正操作的原子操作,以下分别是左旋右旋的具体示例: 对于节点5的左旋操作 对于节点10的右旋操作 插入策略 将插入的节点node置为红色 根据不同的情况进行重新置色并且进行矫正. 具体分为四种情况 case0: 如果node = root,将其置为黑色 case1: 如果node.uncle.color= red,将node的父亲和叔叔节点变成黑色,并将祖父节点变成红色 case2: 如果node.uncle.color = black,并且(node,node.parent,node.grandparent)三点呈三角形,这是需要旋转node的parent向node的反方向(即如果node = node.parent.left,那么需要右旋node.parent). case3: 如果node.uncle.color = black,并且(node,node.parent,node.grandparent)三点呈直线,这是需要旋转node的grandparent向node的反方向,并且对node.parent和node.grandparent重新置色. 重复上述过程向root节点回溯,直到牵涉的节点都符合了红黑树的定义，修复操作结束. 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179package com.hcb.algorithm.chapter2;/** * 红黑树 */public class RBTree &#123; public RBTreeNode root; public static class RBTreeNode&lt;T extends Comparable&lt;T&gt;&gt; &#123; public T value; public RBTreeNode left; public RBTreeNode right; public RBTreeNode parent; public boolean red ; public RBTreeNode(T v) &#123; this.left = null; this.right = null; this.parent = null; value = v; &#125; &#125; public static void prePrint(RBTreeNode bt) &#123; if (bt == null) &#123; return; &#125; else &#123; System.out.print(bt.value + \" \"+bt.red); if(bt.parent!= null)&#123; System.out.println(\"(parent node:\"+bt.parent.value+\")\"); &#125;else &#123; System.out.println(\"(parent null)\"); &#125; prePrint(bt.left); prePrint(bt.right); &#125; &#125; public static void insert(RBTree rbTree,RBTree.RBTreeNode node)&#123; RBTree.RBTreeNode y = null; RBTree.RBTreeNode x = rbTree.root; while (x!=null)&#123; y = x; if(node.value.compareTo(x.value)&lt;0)&#123; x = x.left; &#125;else &#123; x = x.right; &#125; &#125; node.parent = y; if(y == null)&#123; rbTree.root = node; &#125;else if(node.value.compareTo(y.value)&lt;0) &#123; y.left = node; &#125;else &#123; y.right = node; &#125; node.left = null; node.right = null; node.red = true; insertFixup(rbTree,node); &#125; private static void insertFixup(RBTree rbTree, RBTreeNode node) &#123; if(node.parent == null)&#123; //case0 node是root node.red = false; return; &#125;else if(node.parent.parent == null)&#123; return; &#125; RBTreeNode y = null; while(node.parent != null &amp;&amp; node.parent.red)&#123; //如果node的父亲是祖父的左孩子 if(node.parent == node.parent.parent.left)&#123; //y 是node的叔叔节点 y = node.parent.parent.right; if(y!=null &amp;&amp; y.red)&#123; //case1 node.parent.red =false; y.red = false; node.parent.parent.red = true; node = node.parent.parent; //执行之后,node的指向向上了两层,仍然指向红色 &#125;else&#123; if(node == node.parent.right)&#123; //case2 triangle型 node = node.parent; leftRotate(rbTree,node); //上边的左旋操作执行后,变成了case3 即line型的 &#125; //case3 line型 node.parent.red = false; node.parent.parent.red = true; rightRotate(rbTree,node.parent.parent); // 直线型执行之后,node的指向的虽然没改变,但是其指向的结点上升了一层 &#125; &#125; // 如果node的父亲是祖父的右孩子,逻辑与上面相同,只不过左右交换一下的这种情况 else &#123; y = node.parent.parent.left; if(y!=null &amp;&amp; y.red)&#123; node.parent.red = false; y.red = false; node.parent.parent.red = true; node = node.parent.parent; &#125;else &#123; if(node == node.parent.left)&#123; //triangle node = node.parent; rightRotate(rbTree,node); //上边执行完,变成line型 &#125; //line型 node.parent.red = false; node.parent.parent.red = true; leftRotate(rbTree,node.parent.parent); &#125; &#125; rbTree.root.red = false; &#125; &#125; private static void rightRotate(RBTree rbTree, RBTreeNode node) &#123; RBTreeNode y = node.left; node.left = y.right; if(y.right != null)&#123; y.right.parent = node; &#125; y.parent = node.parent; if(node.parent ==null)&#123; rbTree.root = y; &#125;else if(node == node.parent.right)&#123; node.parent.right = y; &#125;else &#123; node.parent.left = y; &#125; y.right = node; node.parent = y; &#125; private static void leftRotate(RBTree rbTree, RBTreeNode node) &#123; RBTreeNode y = node.right; node.right = y.left; if(y.left != null)&#123; y.left.parent = node; &#125; y.parent = node.parent; if(node.parent == null)&#123; rbTree.root = y; &#125;else if(node == node.parent.left)&#123; node.parent.left = y; &#125;else &#123; node.parent.right = y; &#125; y.left = node; node.parent = y; &#125; public static void main(String[] args) &#123; RBTree rbTree = new RBTree();; insert(rbTree,new RBTreeNode(19)); insert(rbTree,new RBTreeNode(15)); insert(rbTree,new RBTreeNode(12));// prePrint(rbTree.root); insert(rbTree,new RBTreeNode(33));// prePrint(rbTree.root); insert(rbTree,new RBTreeNode(37)); insert(rbTree,new RBTreeNode(10)); insert(rbTree,new RBTreeNode(25)); insert(rbTree,new RBTreeNode(24)); prePrint(rbTree.root); &#125;&#125; reference https://www.youtube.com/watch?v=qvZGUFHWChY&amp;list=PL9xmBV_5YoZNqDI8qfOZgzbqahCUmUEin https://www.cs.usfca.edu/~galles/visualization/RedBlack.html","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"红黑树","slug":"红黑树","permalink":"http://yoursite.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"}]},{"title":"采用partition方法的典型题目以及时间复杂度数学计算分析","slug":"采用partition方法的典型题目以及时间复杂度数学计算分析","date":"2020-02-15T02:58:23.000Z","updated":"2020-02-18T03:25:13.000Z","comments":true,"path":"2020/02/15/采用partition方法的典型题目以及时间复杂度数学计算分析/","link":"","permalink":"http://yoursite.com/2020/02/15/%E9%87%87%E7%94%A8partition%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B8%E5%9E%8B%E9%A2%98%E7%9B%AE%E4%BB%A5%E5%8F%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%88%86%E6%9E%90/","excerpt":"partition的解题思路广泛应用于 将一个问题根据某一规则分割成两个子问题 的这种情况,是分而治之思想的一个具体实例,其缺点是不稳定,会改变元素在数组中的位置.以下是使用partition方法的两个经典题目,以及如何计算它们的时间复杂度.","text":"partition的解题思路广泛应用于 将一个问题根据某一规则分割成两个子问题 的这种情况,是分而治之思想的一个具体实例,其缺点是不稳定,会改变元素在数组中的位置.以下是使用partition方法的两个经典题目,以及如何计算它们的时间复杂度. partition代码 1234567891011121314151617181920212223// 任意选择一个pivot,使得pivot左边的元素小于pivot,pivot右边的元素大于pivotprivate static int partition(int[] arr, int start, int end) &#123; int index = start + (int)(Math.random() * (end-start)); swap(arr,index,end); int small = start-1; for(index = start;index&lt;end;++index)&#123; if(arr[index]&lt;arr[end])&#123; ++small; if(small != index)&#123; swap(arr,index,small); &#125; &#125; &#125; ++small; swap(arr,small,end); return small; &#125; private static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; 快速排序 思路 每次选择一个pivot元素,使得pivot左边的元素小于pivot,pivot右边的元素大于pivot.之后分别进行递归处理左边和右边的部分. 代码 12345678910111213141516171819202122232425package com.hcb.algorithm.chapter4;import java.util.Arrays;public class Sword39 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,2,2,2,5,4,2&#125;; quikSort(arr,0,arr.length-1); System.out.println(Arrays.toString(arr)); &#125; private static void quikSort(int[] arr,int start,int end)&#123; if(start == end)&#123; return; &#125; int index = partition(arr,start,end); if(index &gt; start)&#123; quikSort(arr,start,index-1); &#125; if(index &lt; end)&#123; quikSort(arr,index+1,end); &#125; &#125;&#125; 时间复杂度 最好情况 最好情况是每次选择的pivot元素正好位于中间位置,这时时间复杂度的计算过程如下: 其递推公式为 最好情况的递推公式 其中，O(n)为一次partition所需要的时间，设为cn。因此： \\[ \\begin{aligned} T(n) &amp;=2 T\\left(\\frac{n}{2}\\right)+c n=2\\left(2 T\\left(\\frac{n}{4}\\right)+\\frac{c n}{2}\\right)+c n=2^{2} T\\left(\\frac{n}{4}\\right)+2 c n \\\\ &amp;=2^{3} T\\left(\\frac{n}{8}\\right)+3 c n=\\ldots=2^{k} T\\left(\\frac{n}{2^{k}}\\right)+k c n \\\\ &amp;=n O(1)+c n \\log _{2} n \\\\ &amp;=O\\left(n \\log _{2} n\\right),\\left(\\operatorname{假设} n=2^{k}, \\text {则 } k=\\log _{2} n\\right) \\end{aligned} \\] 快速排序在最好的情况下时间复杂度为O(nlgn) 最坏情况 最坏情况为每次选择的pivot元素是序列的最大或最小元素,这样相当于每次都是冒泡一个出去,其时间复杂度为 \\[ \\begin{aligned} T(n)&amp;=n+(n-1)+(n-2)+\\ldots+1\\\\ &amp;=\\sum_{i=1}^{n}i = \\frac{n(1+n)}{2}\\\\ &amp;=O(n^{2}) \\end{aligned} \\] 平均情况 设pivot按大小顺序所在的位置为i,那么左边部分有i个元素,右边部分有n-1-i个元素,因此 其递推公式为 rendered_image1 随机选取的pivot元素出现在序列的每个位置的概率都是均等的,都是1/n,因此T(i)的平均值为\\(\\frac{1}{n}\\sum_{j=0}^{n-1}T(j)\\) ,同样,n-1-i的取值也是每个位置的概率是均等的,因此T(n-1-i)的平均值也为\\(\\frac{1}{n}\\sum_{j=0}^{n-1}T(j)\\),因此 \\[ T(n)=\\frac{2}{n}\\left[\\sum_{j=0}^{n-1} T(j)\\right]+c n \\] 两边同乘n得 \\[ nT(n)=2\\left[\\sum_{j=0}^{n-1} T(j)\\right]+c n^{2} \\] 把n换成n-1得 \\[ (n-1) T(n-1)=2\\left[\\sum_{j=0}^{n-2} T(j)\\right]+c(n-1)^{2} \\] 上面两个等式相减得 \\[ nT(n)-(n-1) T(n-1)=2 T(n-1)+2 c n-c \\] 即 \\[ n T(n)=(n+1) T(n-1)+2 c n \\] 现在已经得到仅用T(n-1)表示的T(n),使n分别取n….2,得到 \\[ \\frac{T(n)}{n+1}=\\frac{T(n-1)}{n}+\\frac{2 c}{n+1}\\\\[3ex] \\] \\[ \\frac{T(n-1)}{n}=\\frac{T(n-2)}{n-1}+\\frac{2 c}{n}\\\\[3ex] \\] \\[ \\frac{T(n-2)}{n-1}=\\frac{T(n-3)}{n-2}+\\frac{2 c}{n-1}\\\\[3ex] \\] \\[ \\vdots\\ \\\\[3ex] \\] \\[ \\frac{T(2)}{3}=\\frac{T(1)}{2}+\\frac{2 c}{3} \\] 左右两边合并得到 \\[ \\frac{T(n)}{n+1}=\\frac{T(1)}{2}+2 c \\sum_{i=3}^{n+1} \\frac{1}{i} \\] ​ 其中\\(\\sum_{i=3}^{n+1} \\frac{1}{i}\\)这部分为调和级数的一部分,其大小为\\(\\log _{e}(n+1)+\\gamma-\\frac{3}{2}\\) ,其中\\(\\gamma\\)为欧拉常数,因此 \\[ \\frac{T(n)}{n+1}=O(\\log n)\\\\[3ex] \\] \\[ T(n)=O(n \\log n) \\] 获得次数超过一半的数字 题目描述 输入数组中存在一个数字出现的次数超过了数组长度的一半,请找出这个数字 解题思路 如果存在一个数字出现的次数超过数组长度的一半,那么该数组的中位数一定是该数字. 在进一步,如果利用partition的思想,其partition之后的pivot元素如果恰好落在正中间,那么它一定是中位数,那么也就是我们要找的这个数字. 代码实现 123456789101112131415161718192021222324252627package com.hcb.algorithm.chapter4;import java.util.Arrays;public class Sword39 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,2,2,2,5,4,2&#125;; int result = moreThanHalfNum(arr); System.out.println(result); &#125; private static int moreThanHalfNum(int[] arr) &#123; int middle = arr.length &gt;&gt;1; int start = 0; int end = arr.length-1; int index = partition(arr,start,end); while(index != middle)&#123; if(index &gt; middle)&#123; index = partition(arr,start,index-1); &#125;else &#123; index = partition(arr,index+1,end); &#125; &#125; return arr[middle]; &#125;&#125; 时间复杂度 这个问题的平均时间复杂度很容易被认为类似快速排序的O(nlogn),但是其时间复杂是O(n).因为快排会递归处理划分的两边,而这个问题只需要递归地处理一边.具体计算过程如下 \\[ \\begin{aligned} T(n) &amp;=n+\\frac{n}{2}+\\frac{n}{2^{2}}+\\frac{n}{2^{3}} +\\ldots+\\frac{n}{2^{k}}\\\\ &amp;=n*(1+\\frac{1}{2}+\\frac{1}{2^{2}}+\\frac{1}{2^{3}} +\\ldots+\\frac{1}{2^{k}}) \\\\ &amp;=n*(2-\\frac{1}{2^{k-1}}) \\\\ &amp;&lt;2n \\\\ \\end{aligned} \\] 因此,其时间复杂度为O(n). Reference &lt;&gt;第二版 &lt;&lt;数据结构与算法分析：C语言描述&gt;&gt;原书第2版","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"时间复杂度","slug":"时间复杂度","permalink":"http://yoursite.com/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"name":"数学证明","slug":"数学证明","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E/"},{"name":"partition","slug":"partition","permalink":"http://yoursite.com/tags/partition/"}]},{"title":"全排列以及相似问题扩展","slug":"全排列问题","date":"2020-02-12T16:16:10.000Z","updated":"2020-02-15T17:58:37.000Z","comments":true,"path":"2020/02/13/全排列问题/","link":"","permalink":"http://yoursite.com/2020/02/13/%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/","excerpt":"题目描述 输入一个字符串,得到出该字符串中字符的所有排列. 输入 abc 输出 abc acb bac bca cab cba 解题思路 遍历序列,每个元素与第一个元素交换 递归处理从第二个元素开始的序列 时间复杂度为n(n-1)(n-2)…2*1,即O(n!)","text":"题目描述 输入一个字符串,得到出该字符串中字符的所有排列. 输入 abc 输出 abc acb bac bca cab cba 解题思路 遍历序列,每个元素与第一个元素交换 递归处理从第二个元素开始的序列 时间复杂度为n(n-1)(n-2)…2*1,即O(n!) 代码 1234567891011121314151617181920212223242526private static ArrayList&lt;String&gt; ret = new ArrayList&lt;&gt;();private static ArrayList&lt;String&gt; myPermutation(String str) &#123; if (str.length() == 0) return ret; char[] chars = str.toCharArray(); backtracking2(chars,0,new StringBuilder()); return ret; &#125; private static void backtracking2(char[] chars, int start ,StringBuilder s) &#123; if (s.length() == chars.length) &#123; ret.add(s.toString()); return; &#125; for (int i = start; i &lt;chars.length ; i++) &#123; char tmp = chars[start]; chars[start] = chars[i]; chars[i] = tmp; s.append(chars[start]); backtracking2(chars,start+1,s); s.deleteCharAt(s.length()-1); tmp = chars[start]; chars[start] = chars[i]; chars[i] = tmp; &#125; &#125; 进一步 在输入序列有重复元素的情况中,上面的解题思路会出现重复序列,比如输入为bcb,那么会生成6个结果序列,但是只有3个序列是互不重复的. 解决思路 将输入序列排序,使重复元素相邻,这样容易在遍历的过程中判断该元素是否有相同元素 因为输入需要保证输入序列有序,所以不能进行遍历元素与首元素交换,这样会破坏有序,并且使问题变得复杂.那么该怎么确定一个元素已经在输出序列中了呢?采用标记数组的方式. 遍历过程中,如果该元素与其前一个相同,会出现两种情况: 前一个元素不在输出序列中,说明以 前一个元素为首元素的最终序列已经完成,这时应该跳过该元素. 前一个元素在输出序列中,说明以 前一个元素为首元素的最终序列还未完成,所以该元素应该作为序列的一部分进行处理 举个例子: 输入序列为bbc,这时遍历到第二个b的位置,两种情况 前一个b不在输出序列中,说明以 前一个b为首元素的最终序列已经完成(即bbc和bcb),这时应该跳过该元素(即此时遍历的位置,第二个b). 前一个b在输出序列中,说明以 前一个b为首元素的最终序列还未完成,所以该元素应该作为序列的一部分进行处理 代码 123456789101112131415161718192021222324252627282930private static ArrayList&lt;String&gt; ret = new ArrayList&lt;&gt;();public static ArrayList&lt;String&gt; Permutation(String str) &#123; if (str.length() == 0) return ret; char[] chars = str.toCharArray(); Arrays.sort(chars); backtracking(chars, new boolean[chars.length], new StringBuilder()); return ret;&#125;private static void backtracking(char[] chars, boolean[] hasUsed, StringBuilder s) &#123; if (s.length() == chars.length) &#123; ret.add(s.toString()); return; &#125; for (int i = 0; i &lt; chars.length; i++) &#123; if (hasUsed[i]) continue; if (i != 0 &amp;&amp; chars[i] == chars[i - 1] &amp;&amp; !hasUsed[i - 1]) /* 保证不重复 */ continue; hasUsed[i] = true; s.append(chars[i]); backtracking(chars, hasUsed, s); s.deleteCharAt(s.length() - 1); hasUsed[i] = false; &#125;&#125; 扩展1 5个元素取3个的排列怎么解决? 同样采用递归的思路: 先确定第一个元素,然后解决4个里面取两个... 扩展2 5个元素取3个的组合怎么解决? 因为组合问题不涉及输出序列的元素顺序不需要考虑,即abc和bac属于同一种组合,因此不需要把每个元素依次当做首元素. 解决思路 以\"abcde\"这个输入序列为例. 采用递归的思路,先将a作为结果序列的第一个元素,之后得到从bcde这个序列中取两个元素的组合 之后将b作为结果序列的第一个元素时,这时结果序列中应该排除a元素,因为包含ab的输出序列在第一步中已经输出完毕,因此下一步应该得到cde这个序列中取两个元素的组合 示例代码 123456789101112131415161718192021222324package com.hcb.algorithm.chapter4;public class Sword38$2 &#123; public static void main(String[] args) &#123; printCombination(\"abcde\",3); &#125; private static void printCombination(String string, int num) &#123; char[] chars = string.toCharArray(); printCombinationRec(chars,0,num,new StringBuilder()); &#125; private static void printCombinationRec(char[] chars, int start, int num, StringBuilder str) &#123; if(str.length() == 3)&#123; System.out.println(str); return; &#125; for (int j = start; j &lt; chars.length; j++) &#123; str.append(chars[j]); printCombinationRec(chars,j+1,num-1, str); str.deleteCharAt(str.length()-1); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"元素任意的数组找出3个数的乘积最大","slug":"元素任意的数组找出3个数的乘积","date":"2020-02-06T17:52:41.000Z","updated":"2020-02-15T18:00:15.000Z","comments":true,"path":"2020/02/07/元素任意的数组找出3个数的乘积/","link":"","permalink":"http://yoursite.com/2020/02/07/%E5%85%83%E7%B4%A0%E4%BB%BB%E6%84%8F%E7%9A%84%E6%95%B0%E7%BB%84%E6%89%BE%E5%87%BA3%E4%B8%AA%E6%95%B0%E7%9A%84%E4%B9%98%E7%A7%AF/","excerpt":"题目描述 给定一个无序数组，包含正数、负数和0，要求从中找出3个数的乘积，使得乘积最大，要求时间复杂度：O(n)，空间复杂度：O(1) 输入描述 输入共2行，第一行包括一个整数n，表示数组长度 第二行为n个以空格隔开的整数，分别为A1,A2, … ,An 输出描述 满足条件的最大乘积","text":"题目描述 给定一个无序数组，包含正数、负数和0，要求从中找出3个数的乘积，使得乘积最大，要求时间复杂度：O(n)，空间复杂度：O(1) 输入描述 输入共2行，第一行包括一个整数n，表示数组长度 第二行为n个以空格隔开的整数，分别为A1,A2, … ,An 输出描述 满足条件的最大乘积 示例 输入 1243 4 1 2 输出 124 解题思路 通过维持三元组来解决,因为元素正负零都有可能,所以需要维护几个三元组来应对每种情况 若有三个元素,则直接返回 若有超过4个元素,且存在正元素,那么结果一定为正,对应三正和两负一正 两种情况. 在没有正元素的情况中: 如果存在0,那么结果一定为0; 如果不存在0,那么结果一定为负; 注意 :大数的情况,long类型接收乘积. 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.hcb.algorithm.others;import java.util.Scanner;public class Example &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int len =Integer.parseInt(sc.nextLine()); String str = sc.nextLine(); String[] str_arr = str.split(\" \"); int [] arr = new int[str_arr.length]; for (int i = 0; i &lt; str_arr.length ; i++) &#123; arr[i] = Integer.parseInt(str_arr[i]); &#125; long max = getMaxMulti(arr); System.out.println(max); &#125; private static long getMaxMulti(int[] arr) &#123; boolean zeroFlag = false; boolean posFlag = false; // 三个元素按递增排列 int[] po3 = &#123;0,0,0&#125;; //(1) 正 int[] po1ne2 = &#123;0,0,0&#125;; //(3) 正 int[] ne3 = &#123;Integer.MIN_VALUE,Integer.MIN_VALUE,Integer.MIN_VALUE&#125;; // (4) 负 if(arr.length == 3)&#123; return (long)arr[0]*(long)arr[1]*(long)arr[2]; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; if(arr[i] == 0)&#123; zeroFlag = true; &#125; else if(arr[i] &gt; 0)&#123; posFlag = true; // (2)(4)不考虑 //(1) if(arr[i]&gt;po3[2])&#123; po3[0] = po3[1]; po3[1] = po3[2]; po3[2] = arr[i]; &#125;else if(arr[i]&gt;po3[1])&#123; po3[0] = po3[1]; po3[1] = arr[i]; &#125;else if(arr[i]&gt;po3[0])&#123; po3[0] = arr[i]; &#125; //(3) if(arr[i] &gt; po1ne2[2])&#123; po1ne2[2] = arr[i]; &#125; &#125;else &#123; // (3) 两个负的越小越好 if(arr[i]&lt; po1ne2[1])&#123; if(arr[i]&lt;po1ne2[0])&#123; po1ne2[1] = po1ne2[0]; po1ne2[0] = arr[i]; &#125;else &#123; po1ne2[1] = arr[i]; &#125; &#125; // (4) 三个负的越大越好 if(arr[i]&gt;ne3[2])&#123; ne3[0] = ne3[1]; ne3[1] = ne3[2]; ne3[2] = arr[i]; &#125;else if(arr[i]&gt;ne3[1])&#123; ne3[0] = ne3[1]; ne3[1] = arr[i]; &#125;else if(arr[i] &gt; ne3[0])&#123; ne3[0] = arr[i]; &#125; &#125; &#125; if(posFlag)&#123; return Math.max((long)(po3[0]*(long)po3[1]*(long)po3[2]),((long)po1ne2[0]*(long)po1ne2[1]*(long)po1ne2[2])); &#125;else if(zeroFlag)&#123; return 0; &#125;else &#123; return (long)ne3[0]*(long)ne3[1]*(long)ne3[2]; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"贪心算法解决剪绳子问题的正确性证明","slug":"贪心算法解决剪绳子问题的正确性证明","date":"2019-09-25T15:29:22.000Z","updated":"2020-02-15T18:01:24.000Z","comments":true,"path":"2019/09/25/贪心算法解决剪绳子问题的正确性证明/","link":"","permalink":"http://yoursite.com/2019/09/25/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E5%89%AA%E7%BB%B3%E5%AD%90%E9%97%AE%E9%A2%98%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E/","excerpt":"问题描述: 给你一根长度为n的绳子，请把绳子剪成m段,（m，n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[1],k[2]…k[m].请问k[1]×k[2]×…×k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，剪成长度为2,3,3的三段，此时得到的最大乘积是18.","text":"问题描述: 给你一根长度为n的绳子，请把绳子剪成m段,（m，n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[1],k[2]…k[m].请问k[1]×k[2]×…×k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，剪成长度为2,3,3的三段，此时得到的最大乘积是18. 贪心法解法: 如果我们按照如下的策略来剪绳子，则得到的各段绳子的长度的乘积将最大: 当n≥5时，我们尽可能多地剪长度为3的绳子; 当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子。 这样时间复杂度为o(1) 参考代码 12345678910111213141516171819// 贪心 private int getMaxMul3(int n) &#123; if(n==1)&#123; return 0; &#125;else if(n==2)&#123; return 1; &#125;else if(n==3)&#123; return 2; &#125;else &#123; int times = n/3; if(n%3 == 0)&#123; return (int) Math.pow(3,times); &#125;else if(n%3 == 1)&#123; return (int)Math.pow(3,times-1) *2*2; &#125;else &#123; return (int)Math.pow(3,times)*2; &#125; &#125; &#125; 正确性证明 理论前提 当n&gt;=5时,3(n-3)&gt;n一定成立,即切成3和n-3的两段更优; 当n&gt;=5时,2(n-2)&gt;n一定成立,即切成2和n-2的两段更优; 当n&gt;=5时,3(n-3)&gt;=2(n-2)&gt;1(n-1)一定成立,即切成3和n-3的两段比切成2和n-2更优; 证明 有了上面的理论前提,可以得到如下结论: 当绳子段长度&gt;=5时,中间切一刀肯定比不切得到的结果更优,所以最终得到的子段中只能存在1,2,3,4这四种类型. 更进一步,子段长度为4可以切割成2,2 其结果也是4 这样可以进一步收缩结果为 最终子段只能存在1,2,3这三种类型. 更进一步,当n&gt;=5时,只能有三种切法:一种是切成3和n-3;另一种是切成2和n-2;1和n-1. 根据理论前提3,第一种切法更优,因此倾向于每次都切出来一个长度为3的子段,这样造成的结果是,3越多越好. 更进一步,如果最后切完的结果是m个3,和一个1, 这种情况下,将1与一个3合成为一个4,再将这个4切成两个2,最终成为m-1个3和两个2,这样结果更优. 结论 综上，我们得出结论，每一刀次都切出来一个长度为3的子段,最终的剩余字段长度有三种情况: 如果剩余子段长度为2,则最终结果为m个3和一个2. 如果剩余子段长度为1,则最终结果为m-1个3和两个2. 如果没有剩余,则最终结果是m个3.","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"数学证明","slug":"数学证明","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E/"}]},{"title":"Mac系统下在IDEA配置Kafka2.3.0源码阅读以及二次开发环境","slug":"Mac系统下在IDEA配置Kafka源码阅读修改环境","date":"2019-09-23T18:11:41.000Z","updated":"2020-02-27T12:29:18.000Z","comments":true,"path":"2019/09/24/Mac系统下在IDEA配置Kafka源码阅读修改环境/","link":"","permalink":"http://yoursite.com/2019/09/24/Mac%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%9C%A8IDEA%E9%85%8D%E7%BD%AEKafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83/","excerpt":"","text":"环境 Java 8 本机版本java version \"1.8.0_141\" Gradle 5.0 or higher 本机版本Gradle 5.4.1 默认Scala 2.12,但也可以通过自定义的方式使用其他的scala版本. 本机版本Scala code runner version 2.12.8 IDEA scala插件 本机版本 v2018.3.7 将代码导入到IDEA 将代码克隆到当前文件夹 git clone -b 2.3.0 https://github.com/apache/kafka.git 在下载的项目根目录下执行gradle的idea task gradle idea 通过代码编译执行启动kafka服务 kafka服务需要zookeeper管理元数据,kafka服务的启动所以需要有zookeeper服务运行作为保证,zookeeper服务的ip:port需要配置到config/server.properties. kafka的消息是以日志文件的形式存储的,所以还需要配置消息日志的存储路径 本机config/server.properties添加的配置如下 12log.dirs&#x3D;&#x2F;Volumes&#x2F;Macintosh\\ HD&#x2F;teacher_project&#x2F;kafka230_logDir&#x2F;kafka_logszookeeper.connect&#x3D;kafka:2181 编辑启动配置项 kafka服务程序配置 启动kafka服务程序 启动 排坑 org.apache.kafka.common.message不存在 启动的build过程中,会出现org.apache.kafka.common.message不存在的Error.新版kafka将request和response的格式类改成自动生成了,所以缺少org.apache.kafka.common.message这个package,因此需要执行gradle的jarall task (参考),生成的message包会以generated包的形式存在,将生成的message包移动到org.apache.kafka.common的位置. gradle jarall java.lang.stackOverflowError 启动的build过程中,会出现java.lang.stackOverflowError stackOverflowError 这是因为javac的编译检查设置造成的,比如范型使用不规范会出现这个问题,这个问题通过修改java compiler的配置解决 配置 Failed to load class \"org.slf4j.impl.StaticLoggerBinder\" 提示:https://www.slf4j.org/codes.html#StaticLoggerBinder 这是由于没有slf4j的实现jar包.解决方式为将slf4j-log4j12.jar加入到core/main的dependency中. 加入log4j的依赖 log4j:WARN No appenders could be found for logger 由于没有log的配置文件,将config/log4j.properties分别复制到core/src/main/scala和core/out/production/classes中 复制log4j.properties log4j:ERROR setFile(null,true) call failed. java.io.FileNotFoundException: /logs/server.log 这是由于未能找到日志的输出路径. log4j.propertties中的这种配置log4j.appender.stateChangeAppender.File=${kafka.logs.dir}/logs/state-change.log,得不到${kafka.logs.dir},有两种解决方式: 可以将${kafka.logs.dir}改成绝对路径 通过配置启动项的方式,将kafka.logs.dir的值加入到vm的参数中(参考) -Dproperty=value Sets a system property value. The property variable is a string with no spaces that represents the name of the property. The value variable is a string that represents the value of the property. If value is a string with spaces, then enclose it in quotation marks (for example -Dfoo=\"foo bar\"). 参考 VM options","categories":[{"name":"kafka","slug":"kafka","permalink":"http://yoursite.com/categories/kafka/"}],"tags":[{"name":"kafka源码","slug":"kafka源码","permalink":"http://yoursite.com/tags/kafka%E6%BA%90%E7%A0%81/"}]},{"title":"如何理解一个javaAPI中定义的线程安全的类并不能保证绝对线程安全","slug":"如何理解一个javaAPI中定义的线程安全的类并不能保证绝对线程安全","date":"2019-08-30T14:39:26.000Z","updated":"2020-02-15T17:53:36.000Z","comments":true,"path":"2019/08/30/如何理解一个javaAPI中定义的线程安全的类并不能保证绝对线程安全/","link":"","permalink":"http://yoursite.com/2019/08/30/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E4%B8%80%E4%B8%AAjavaAPI%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB%E5%B9%B6%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E7%BB%9D%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/","excerpt":"绝对的线程安全完全满足Brian Goetz给出的线程安全的定义，这个定义其实是很严格的，一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大的，其至有时候是不切实际的代价。在JavaAPI中标注自已是线程安全的类，大多数都不是绝对的线程安全。我们可以通过JavaAPI中一个不是“绝对线程安全”的线程安全.","text":"绝对的线程安全完全满足Brian Goetz给出的线程安全的定义，这个定义其实是很严格的，一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大的，其至有时候是不切实际的代价。在JavaAPI中标注自已是线程安全的类，大多数都不是绝对的线程安全。我们可以通过JavaAPI中一个不是“绝对线程安全”的线程安全. 示例代码 这段代码有可能会出现数组越界异常 123456789101112131415161718192021222324252627282930313233private static Vector&lt;Integer&gt; vector = new Vector&lt;Integer&gt;(); public static void main(String[] args) &#123; while (true) &#123; for (int i = 0; i &lt; 10; i++) &#123; vector.add(i); &#125; Thread removeThread = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; &#125; &#125;); Thread printThread = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; System.out.println((vector.get(i))); &#125; &#125; &#125;); removeThread.start(); printThread.start(); //不要同时产生过多的线程，否则会导致操作系统假死 while (Thread.activeCount() &gt; 20); &#125; &#125; 可能情况 什么情况下可能会出现ArrayIndexOutOfBoundsException? 尽管这里使用到的Vector的get()、remove() 和size()方法都是同步的，但是在多线程的环境中，如果不在方法调用端做额外的同步措施的话，使用这段代码仍然是不安全的，因为如果另一个线程恰好在错误的时间里删除了一个元素，导致序号i已经不再可用的话，再用i访问数组就会抛出一个ArrayIndexOutOfBoundsException。 举例,这种执行顺序可能会出现ArrayIndexOutOfBoundsException. removeThread线程 i = 9时,去判断i&lt;vector.size(),removeThread线程调用vector.size() = 10 ,这时切换到printThread. 同样 printThread线程i = 9,去判断i&lt;vector.size(),removeThread线程调用vector.size() = 10, 这时切换到removeThread. removeThread线程 ,将i为9的元素remove.这时切换到printThread. printThread线程去get i = 9 的元素,这时就会发生ArrayIndexOutOfBoundsException. 参考 ​ 《深入理解java虚拟机 JVM高级特性与最佳实践》第二版","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"线程安全","slug":"线程安全","permalink":"http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"},{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"哔哩哔哩20190820算法题","slug":"哔哩哔哩20190820算法题","date":"2019-08-20T20:55:22.000Z","updated":"2020-02-15T18:02:25.000Z","comments":true,"path":"2019/08/21/哔哩哔哩20190820算法题/","link":"","permalink":"http://yoursite.com/2019/08/21/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A920190820%E7%AE%97%E6%B3%95%E9%A2%98/","excerpt":"题目描述: 找出有序数组(从小到大排列)中和为给定值的两个数,要求复杂度为o(n)，找到一组即可. 输入描述: 第一行:数组长度 第二行:数组各项的值 第三行: sum","text":"题目描述: 找出有序数组(从小到大排列)中和为给定值的两个数,要求复杂度为o(n)，找到一组即可. 输入描述: 第一行:数组长度 第二行:数组各项的值 第三行: sum 输出描述: 若存在，输出和为sum的两个数，以空格分隔;若不存在，输出notfound 示例 输入输出示例仅供调试，后台判题数据般不包含示例 输入 5 1 3 4 6 8 10 输出 4 6 思路 ​ 如果 a[i] + a[k] = sum 的话, 那么sum - a[i]一定在序列中. 代码 1234567891011121314151617181920212223242526272829303132333435363738394041public static void main( String[] args )&#123; Scanner sc = new Scanner(System.in); int len =Integer.parseInt(sc.nextLine()); String str = sc.nextLine(); String[] str_arr = str.split(\" \"); int [] arr = new int[str_arr.length]; for (int i = 0; i &lt; str_arr.length ; i++) &#123; arr[i] = Integer.parseInt(str_arr[i]); &#125; int sum = Integer.parseInt(sc.nextLine()); int[] subArr = new int[len]; for (int i = 0; i &lt; len; i++) &#123; subArr[i] = sum - arr[i]; &#125; int p1 = 0; int p2 = len - 1; while(true)&#123; if(arr[p1] == subArr[p2])&#123; if(p1 != p2)&#123; System.out.print(arr[p1]+\" \"+arr[p2]); break; &#125;else&#123; System.out.println(\"notfound\"); break; &#125; &#125; if(p1 == len || p2 &lt; 0)&#123; System.out.println(\"notfound\"); break; &#125; if(arr[p1]&lt; subArr[p2])&#123; p1++; &#125; if(arr[p1]&gt; subArr[p2])&#123; p2--; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"时间复杂度","slug":"时间复杂度","permalink":"http://yoursite.com/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"}]},{"title":"JVM中描述符和特征签名概念","slug":"JVM中描述符和特征签名概念","date":"2019-08-18T15:48:44.000Z","updated":"2020-02-15T17:22:45.000Z","comments":true,"path":"2019/08/18/JVM中描述符和特征签名概念/","link":"","permalink":"http://yoursite.com/2019/08/18/JVM%E4%B8%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8C%E7%89%B9%E5%BE%81%E7%AD%BE%E5%90%8D%E6%A6%82%E5%BF%B5/","excerpt":"","text":"​ 描述符 : 对于字段来说,用来描述字段的数据类型;对于方法来说,用于描述方法的参数列表(包括数量,类型,以及顺序)和返回值. &lt;&gt;第2版 P176 ​ 特征签名 : 根据上下文的不同,可以分为字节码层面的方法特征签名和java代码层面的方法特征签名. java代码层面的特征签名: 包括了方法名称,参数顺序,以及参数类型. 字节码层面的特征签名: 包括了方法名称,参数顺序,以及参数类型,以及方法返回值和受检查异常表. &lt;&gt;第2版 P180 ​ 所以对于方法重载(overload)来讲,特征签名不同的方法就可以重载,因此在java代码层面和字节码层面有些许不同.在字节码层面,返回值不同,其他的相同也可以看作重载,但对于java来说,我们都知道,重载的判定是和返回值无关的.","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://yoursite.com/tags/jvm/"}]},{"title":"使用alluxio系统对spark checkpoint机制优化","slug":"使用alluxio系统对spark-checkpoint机制优化","date":"2019-07-06T11:19:52.000Z","updated":"2020-02-15T18:13:29.000Z","comments":true,"path":"2019/07/06/使用alluxio系统对spark-checkpoint机制优化/","link":"","permalink":"http://yoursite.com/2019/07/06/%E4%BD%BF%E7%94%A8alluxio%E7%B3%BB%E7%BB%9F%E5%AF%B9spark-checkpoint%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8C%96/","excerpt":"简介 alluxio ​ alluxio作为一个基于内存的分布式文件系统，为上层计算框架和底层存储系统构建了桥梁。主要功能有： 基于内存的访问方式使得吞吐量得到大幅度的性能提升，加速I / O性能。 为分布式计算引擎提供提供了统一了数据访问的方式，以spark为例，如果数据源来自于hdfs，而数据结果保存到s3，那么只需通过配置alluxio分别与hdfs、s3的映射就可以实现统一的数据访问方式，甚至应用程序都不需要知道具体的底层存储系统是什么。 使用Alluxio作为数据访问层，Spark应用程序可以透明地访问许多不同类型和持久存储服务实例中的数据（例如，AWS S3存储桶，Azure对象存储桶，远程HDFS部署等）。 对于计算和数据分离的场景，alluxio对于性能的提升更加充分，尤其是当Spark部署远程数据时。","text":"简介 alluxio ​ alluxio作为一个基于内存的分布式文件系统，为上层计算框架和底层存储系统构建了桥梁。主要功能有： 基于内存的访问方式使得吞吐量得到大幅度的性能提升，加速I / O性能。 为分布式计算引擎提供提供了统一了数据访问的方式，以spark为例，如果数据源来自于hdfs，而数据结果保存到s3，那么只需通过配置alluxio分别与hdfs、s3的映射就可以实现统一的数据访问方式，甚至应用程序都不需要知道具体的底层存储系统是什么。 使用Alluxio作为数据访问层，Spark应用程序可以透明地访问许多不同类型和持久存储服务实例中的数据（例如，AWS S3存储桶，Azure对象存储桶，远程HDFS部署等）。 对于计算和数据分离的场景，alluxio对于性能的提升更加充分，尤其是当Spark部署远程数据时。 spark checkpoint ​ 我们都知道，spark的checkpoint机制是为了容错的，所以checkpoint的数据是必须可靠存储的。对于checkpoint，spark2.4.3以及之前的版本自身所支持的可靠存储的系统必须是兼容于hdfs的，所以checkpoint数据的存取性能受限于io瓶颈的。因此，集成alluxio于checkpoint的使用，将大大提升性能，同时，alluxio2.0提供了异步地从内存向底层存储系统的备份，这样容错能保证而且不会降低性能。 集成 alluxio集群模式搭建 ​ 本例子以部署单节点master,hostname为master，3结点worker,分别为slave1,slave2,slave3为例。生产环境中一定要部署HA模式。在所有的节点中进行如下操作: 下载alluxio2.0 解压 tar xzfv alluxio-2.0.0-bin.tar.gz 配置 cp conf/alluxio-site.properties.template conf/alluxio-site.properties ​ 写入以下配置 123alluxio.master.hostname&#x3D;master# 与hdfs集成,可根据自己情况进行映射alluxio.master.mount.table.root.ufs&#x3D;hdfs:&#x2F;&#x2F;master:9000&#x2F;alluxio2&#x2F;root conf/workers file 填入以下内容: 123slave1slave2slave3 启动hdfs start-dfs.sh 格式化 ./bin/alluxio format 启动 ./bin/alluxio-start.sh all SudoMount 验证 访问alluxio UI http://master:19999,查看alluxio情况. 同样可以运行验证脚本 ./bin/alluxio runTests ​ alluxio UI会出现/default_tests_files文件夹,内容如下 验证页面 与spark集成 确保 /&lt;PATH_TO_ALLUXIO&gt;/client/alluxio-2.0.0-client.jar存在. 生成 spark/conf/spark-defaults.conf cp spark-defaults.conf.template spark-defaults.conf 向spark/conf/spark-defaults.conf写入以下内容, PATH_TO_ALLUXIO 为alluxio的path. 12spark.driver.extraClassPath &#x2F;&lt;PATH_TO_ALLUXIO&gt;&#x2F;client&#x2F;alluxio-2.0.0-client.jarspark.executor.extraClassPath &#x2F;&lt;PATH_TO_ALLUXIO&gt;&#x2F;client&#x2F;alluxio-2.0.0-client.jar 启动yarn start-yarn.sh 启动yarn模式下的spark-shell ./bin/spark-shell --master yarn --deploy-mode client 生成alluxiotest文本文件上传至hdfs://master/alluxio2/root 12vi alluxiotesthadoop fs put alluxio &#x2F;alluxio2&#x2F;root 测试代码 123val s = sc.textFile(\"alluxio://master:19998/alluxiotest\") val double = s.map(line =&gt; line + line)double.saveAsTextFile(\"alluxio://master:19998/alluxiotestOutput\") 问题： ​ 如果出现“NO FILESYSTEM FOR SCHEME: ALLUXIO”这种错误信息是什么原因？ ​ 解决办法：当你的应用（例如MapReduce、Spark）尝试以HDFS兼容文件系统接口访问Alluxio，而又无法解析alluxio://模式时会产生该异常。要确保HDFS配置文件core-site.xml（默认在hadoop安装目录，如果为Spark自定义了该文件则在spark/conf/目录下）包含以下配置： 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.alluxio.impl&lt;/name&gt; &lt;value&gt;alluxio.hadoop.FileSystem&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; ​ 至此,Alluxio已经启动并运行了！你可以访问http://master:19999查看Alluxio master的运行状态，访问http://slave1:30000查看Alluxio worker的运行状态。 测试checkpoint 启动yarn模式下的spark-shell ./bin/spark-shell --master yarn --deploy-mode client 测试代码 1234scala&gt; sc.setCheckpointDir(&quot;alluxio:&#x2F;&#x2F;master:19998&#x2F;testCheckpoint&quot;)scala&gt; val rdd1 &#x3D; sc.parallelize(Array((1,2),(3,4),(5,6),(7,8)),4)scala&gt; rdd1.checkpoint()scala&gt; println(&quot;输出rdd1.........&quot;+rdd1.count()) alluxio UI 的根目录结构 扩展 ​ alluxio中alluxio-site.xml配置中可以通过配置alluxio.user.file.writetype.default 用来设置alluxio write的类型,默认为ASYNC_THROUGH,表示写入alluxio，异步写入UnderFS,这样可以实现checkpoint为persisted的状态.alluxio write的类型还有其他配置,可查阅LIST OF CONFIGURATION PROPERTIES.","categories":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"spark","slug":"spark","permalink":"http://yoursite.com/tags/spark/"},{"name":"alluxio","slug":"alluxio","permalink":"http://yoursite.com/tags/alluxio/"},{"name":"checkpoint","slug":"checkpoint","permalink":"http://yoursite.com/tags/checkpoint/"}]},{"title":"mac终端使用ss代理","slug":"mac终端使用ss代理","date":"2019-05-26T21:06:17.000Z","updated":"2020-02-15T18:14:49.000Z","comments":true,"path":"2019/05/27/mac终端使用ss代理/","link":"","permalink":"http://yoursite.com/2019/05/27/mac%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8ss%E4%BB%A3%E7%90%86/","excerpt":"来由 ​ 在用homebrew安装Apache Thrift时 , 速度惨不忍睹 , 我不禁产生疑问:为什么我挂着ss , 速度还是这么慢 , 后来通过google , 原来知道ss客户端是只能在桌面程序起作用的 , 终端是无法起作用的.如果需要在终端使用ss , 是需要配置的. https://github.com/mrdulin/blog/issues/18#issuecomment-345893277 上面是以zsh进行配置的 , mac自带的terminal 配置和上面基本相同","text":"来由 ​ 在用homebrew安装Apache Thrift时 , 速度惨不忍睹 , 我不禁产生疑问:为什么我挂着ss , 速度还是这么慢 , 后来通过google , 原来知道ss客户端是只能在桌面程序起作用的 , 终端是无法起作用的.如果需要在终端使用ss , 是需要配置的. https://github.com/mrdulin/blog/issues/18#issuecomment-345893277 上面是以zsh进行配置的 , mac自带的terminal 配置和上面基本相同 配置 查看ss使用的代理端口号 ​ 端口号 编辑~/.bashrc文件 添加以下内容 123# proxy list 终端使用代理alias proxy='export all_proxy=socks5://127.0.0.1:1086'alias unproxy='unset all_proxy' 12//生效source ~/.bashrc 验证 首先打开ss全局模式 1234567891011121314151617//查看ip$ curl cip.ccIP : 地址 : 中国 辽宁 沈阳运营商 : 电信//执行proxy$ proxy$ curl cip.ccIP : 地址 : 美国 加利福尼亚州 洛杉矶运营商 : choopa.com// 关闭proxy$ unproxy$ curl cip.ccIP : 地址 : 中国 辽宁 沈阳运营商 : 电信 然后就可以在终端里尽情遨游在自由互联网的海洋中,惬意~","categories":[{"name":"系统","slug":"系统","permalink":"http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://yoursite.com/tags/macOS/"}]},{"title":"spark standalone和yarn模式","slug":"spark的standalone和yarn模式","date":"2019-05-22T12:23:56.000Z","updated":"2020-02-15T17:34:09.000Z","comments":true,"path":"2019/05/22/spark的standalone和yarn模式/","link":"","permalink":"http://yoursite.com/2019/05/22/spark%E7%9A%84standalone%E5%92%8Cyarn%E6%A8%A1%E5%BC%8F/","excerpt":"spark各种部署模式的测试 示例 集群版本 : spark-2.4.3-bin-without-hadoop.tgz 开发环境 : idea sbt 12345// build.sbtname := \"sparkDemo\"version := \"0.1\"scalaVersion := \"2.11.12\"libraryDependencies += \"org.apache.spark\" %% \"spark-core\" % \"2.3.3\"","text":"spark各种部署模式的测试 示例 集群版本 : spark-2.4.3-bin-without-hadoop.tgz 开发环境 : idea sbt 12345// build.sbtname := \"sparkDemo\"version := \"0.1\"scalaVersion := \"2.11.12\"libraryDependencies += \"org.apache.spark\" %% \"spark-core\" % \"2.3.3\" 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243import org.apache.spark.SparkConfimport org.apache.spark.SparkContextobject WordCount &#123; def main(args: Array[String]): Unit = &#123; val inputFile = \"hdfs://master:9000/input.txt\" val conf = new SparkConf().setAppName(\"WordCount\") /** * SparkContext: Driver programs 通过SparkContext对象访问spark * SparkContext对象代表和一个集群的连接 * 在shell中,它是自动创建好的,直接用sc就可以 */ val sc = new SparkContext(conf) /** * textFile就是RDD(Resilient Distributed Datasets), * 弹性分布式数据集, 是分布式内存的一个抽象概念 * 虽然文件分割到不同的机器上,但是仍能用textFile这个变量代表整个文件 */ val textFile = sc.textFile(inputFile) /** *line =&gt; line.split(\" \")是一个匿名函数,line相当于这个函数的参数, * 对每个line都进行split操作, * flatMap将一个元素转变成多个元素 * 比如下边将每个line元素变成split之后的多个元素 * 返回一个新的rdd,即lines */ val lines = textFile.flatMap(line =&gt; line.split(\" \")) /** * word =&gt; (word, 1) * 把每一个word变成(word,1)这种元素 */ val wordCount=lines.map(word =&gt; (word, 1)).reduceByKey((a, b) =&gt; a + b) val output = wordCount.saveAsTextFile(\"hdfs://master:9000/sparkRes\") /** * 上边的例子中, flatMap()和map()都是transformation操作 * reduceByKey()和saveAsTextFile()是action操作 */ &#125;&#125; 1 打包 Project struct下的artifact 2 编译 编译 3 将jar包发到集群 standalone 12345//配置slaves ,这样就可以使用sbin目录下的一些脚本了// 启动一台master,三台worker./sbin/start-all.sh // 提交作业运行./bin/spark-submit --master spark://master:7077 --class WordCount /home/hcb/mySpark/sparkDemo.jar deploy on yarn 在该模式下,不需要启动master和worker,这些资源调度由yarn完成. yarn管理页面:http://master:8088 12345678//关闭master和worker./sbin/stop-all.sh//启动yarnstart-yarn.sh// 提交作业运行./bin/spark-submit --master yarn \\ --deploy-mode cluster \\ --class WordCount /myUpload/myjar/sparkDemo.jar 注 未在远程提交作业是因为,运行一般通过以上方式运行,而使用idea调试,一般使用setMaster(local[n])的方式.","categories":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"spark","slug":"spark","permalink":"http://yoursite.com/tags/spark/"},{"name":"yarn","slug":"yarn","permalink":"http://yoursite.com/tags/yarn/"}]},{"title":"头条2019第二批笔试第一题的java实现","slug":"头条2019第二批笔试第一题的java实现","date":"2019-05-06T22:05:44.000Z","updated":"2020-02-15T18:16:21.000Z","comments":true,"path":"2019/05/07/头条2019第二批笔试第一题的java实现/","link":"","permalink":"http://yoursite.com/2019/05/07/%E5%A4%B4%E6%9D%A12019%E7%AC%AC%E4%BA%8C%E6%89%B9%E7%AC%94%E8%AF%95%E7%AC%AC%E4%B8%80%E9%A2%98%E7%9A%84java%E5%AE%9E%E7%8E%B0/","excerpt":"题目描述","text":"题目描述 1135658-20190414134318919-1652015329 1135658-20190414134340614-1909195790 1135658-20190414134357704-1307810818 1135658-20190414134410650-1912667079 1135658-20190414134424195-738681733 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package com.hcb;import java.util.*;public class Manager2Coder &#123; public static void main(String[] args) &#123; // 输入 Scanner sc = new Scanner(System.in); List&lt;String&gt; list = new ArrayList&lt;&gt;(); String str=\"\"; while(sc.hasNextLine())&#123; str=sc.nextLine(); if(str.equals(\"\"))&#123; break; &#125; list.add(str); &#125; int column = list.get(0).split(\" \").length; int row = list.size(); int[][] arr = new int[row][column]; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt;column ; j++) &#123; arr[i][j]=Integer.parseInt(list.get(i).split(\" \")[j]); &#125; &#125; /** * 如果还存在1,而且和上次相比没有变化,那么就返回0 * 如果存在1,和上次相比变化了,继续执行 * 如果不存在1 返回迭代次数 */ int times = 0; int[][] lastArr = new int[row][column]; List&lt;ArrayList&lt;Integer&gt;&gt; listRef = new ArrayList&lt;&gt;(); while(existsOne(arr,row,column))&#123; deepCopy(arr,lastArr,row,column); saveTolistRef(listRef,arr,row,column); // 开始变化 for (int k = 0; k &lt; listRef.size(); k++) &#123; int i = listRef.get(k).get(0); int j = listRef.get(k).get(1); if(arr[i][j]==2)&#123; if(i-1&gt;=0)&#123; arr[i-1][j]= arr[i-1][j]==1 ? 2:arr[i-1][j]; &#125; if(i+1&lt;row)&#123; arr[i+1][j]= arr[i+1][j]==1 ? 2:arr[i+1][j]; &#125; if(j-1&gt;=0)&#123; arr[i][j-1]= arr[i][j-1]==1 ? 2:arr[i][j-1]; &#125; if(j+1&lt;column)&#123; arr[i][j+1]= arr[i][j+1]==1 ? 2:arr[i][j+1]; &#125; &#125; &#125; for(int i=0;i&lt;arr.length;i++) System.out.println(Arrays.toString(arr[i])); if(!changed(arr,lastArr,row,column)) &#123; System.out.println(\"不能完成 \"+ -1); return; &#125; times++; &#125; System.out.println(\"times \"+ times); &#125; private static void saveTolistRef(List&lt;ArrayList&lt;Integer&gt;&gt; listRef, int[][] arr, int row, int column) &#123; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; column; j++) &#123; if(arr[i][j]==2)&#123; listRef.add(new ArrayList&lt;Integer&gt;(Arrays.asList(i,j))); &#125; &#125; &#125; &#125; private static void deepCopy(int[][] arr,int[][] newArr, int row, int column) &#123; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; column; j++) &#123; newArr[i][j]=arr[i][j]; &#125; &#125; &#125; private static boolean changed(int[][] arr, int[][] lastArr ,int row, int column) &#123; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; column ; j++) &#123; if(arr[i][j]!=lastArr[i][j])&#123; return true; &#125; &#125; &#125; return false; &#125; private static boolean existsOne(int[][] arr,int row ,int column) &#123; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; column ; j++)&#123; if(arr[i][j]==1)&#123; return true; &#125; &#125; &#125; return false; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"二维数组输入","slug":"二维数组输入","permalink":"http://yoursite.com/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BE%93%E5%85%A5/"}]},{"title":"centos7 解决docker启动出现错误","slug":"centos7-解决docker启动出现错误","date":"2019-04-25T18:32:22.000Z","updated":"2020-02-15T17:19:28.000Z","comments":true,"path":"2019/04/26/centos7-解决docker启动出现错误/","link":"","permalink":"http://yoursite.com/2019/04/26/centos7-%E8%A7%A3%E5%86%B3docker%E5%90%AF%E5%8A%A8%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF/","excerpt":"在用yum安装过docker之后,启动出现问题 12&#x2F;&#x2F;启动命令systemctl start docker 12&#x2F;&#x2F;查看状态systemctl status -l docker.service","text":"在用yum安装过docker之后,启动出现问题 12&#x2F;&#x2F;启动命令systemctl start docker 12&#x2F;&#x2F;查看状态systemctl status -l docker.service 错误信息显示:此linux的内核中的SELinux不支持 overlay2 graph driver ，解决方法有两个，要么启动一个新内核，要么就在docker里禁用selinux，--selinux-enabled=false 采用第二种解决方式,更改配置项. 1vi &#x2F;etc&#x2F;sysconfig&#x2F;docker 配置信息 然后启动,成功: 启动成功","categories":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/categories/docker/"}],"tags":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"},{"name":"系统","slug":"系统","permalink":"http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"使用CGLIB实现动态代理功能","slug":"使用CGLIB实现动态代理功能","date":"2019-03-24T21:52:58.000Z","updated":"2020-02-15T16:53:52.000Z","comments":true,"path":"2019/03/25/使用CGLIB实现动态代理功能/","link":"","permalink":"http://yoursite.com/2019/03/25/%E4%BD%BF%E7%94%A8CGLIB%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%9F%E8%83%BD/","excerpt":"示例代码 123456789101112131415161718//被增强的类,即委托类public class ProductDao &#123; public void save()&#123; System.out.println(\"保存商品...\"); &#125; public void update()&#123; System.out.println(\"修改商品...\"); &#125; public void delete()&#123; System.out.println(\"删除商品...\"); &#125; public void find()&#123; System.out.println(\"查询商品...\"); &#125;&#125;","text":"示例代码 123456789101112131415161718//被增强的类,即委托类public class ProductDao &#123; public void save()&#123; System.out.println(\"保存商品...\"); &#125; public void update()&#123; System.out.println(\"修改商品...\"); &#125; public void delete()&#123; System.out.println(\"删除商品...\"); &#125; public void find()&#123; System.out.println(\"查询商品...\"); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536//动态代理,使用的是spring中的cglib包import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class MyCglibProxy implements MethodInterceptor&#123; private ProductDao productDao; public MyCglibProxy(ProductDao productDao)&#123; this.productDao = productDao; &#125; public Object createProxy()&#123; // 1.创建核心类 Enhancer enhancer = new Enhancer(); // 2.设置父类 enhancer.setSuperclass(productDao.getClass()); // 3.设置回调 enhancer.setCallback(this); // 4.生成代理 Object proxy = enhancer.create(); return proxy; &#125; public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; if(\"save\".equals(method.getName()))&#123; System.out.println(\"权限校验===================\"); return methodProxy.invokeSuper(proxy,args); &#125; return methodProxy.invokeSuper(proxy,args); &#125;&#125; 测试 12345678910111213141516//测试类import org.junit.Test;public class SpringDemo2 &#123; @Test public void demo1()&#123; ProductDao productDao = new ProductDao(); ProductDao proxy = (ProductDao) new MyCglibProxy(productDao).createProxy(); proxy.save(); proxy.update(); proxy.delete(); proxy.find(); &#125;&#125; 使用场景 以上用于实现委托类没有实现接口的的情况.如果委托类有实现接口,也可使用使用jdk的动态代理","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"CGLIB","slug":"CGLIB","permalink":"http://yoursite.com/tags/CGLIB/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"工厂模式以及开闭原则的实现","slug":"工厂模式以及开闭原则的实现","date":"2019-03-12T11:11:22.000Z","updated":"2020-02-15T18:17:36.000Z","comments":true,"path":"2019/03/12/工厂模式以及开闭原则的实现/","link":"","permalink":"http://yoursite.com/2019/03/12/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"定义 工厂模式是我们最常用的实例化对象的模式,是用工厂方法代替new的一种操作 示例 模拟植物大战僵尸中的绿豆,蓝冰,火墙 123456789101112131415161718192021222324252627//Bean.javapublic class Bean &#123; public String getName() &#123; return \"绿逗\"; &#125; public void fight() &#123; System.out.println(\"发射一颗豆子\"); &#125;&#125;//Ice.javapublic class Ice &#123; public String getName() &#123; return \"蓝冰\"; &#125; public void fight() &#123; System.out.println(\"发射一颗冰豆\"); &#125;&#125;//Wall.javapublic class Wall &#123; public String getName() &#123; return \"火墙\"; &#125; public void fight() &#123; System.out.println(\"稳稳的站在草地上\"); &#125;&#125;","text":"定义 工厂模式是我们最常用的实例化对象的模式,是用工厂方法代替new的一种操作 示例 模拟植物大战僵尸中的绿豆,蓝冰,火墙 123456789101112131415161718192021222324252627//Bean.javapublic class Bean &#123; public String getName() &#123; return \"绿逗\"; &#125; public void fight() &#123; System.out.println(\"发射一颗豆子\"); &#125;&#125;//Ice.javapublic class Ice &#123; public String getName() &#123; return \"蓝冰\"; &#125; public void fight() &#123; System.out.println(\"发射一颗冰豆\"); &#125;&#125;//Wall.javapublic class Wall &#123; public String getName() &#123; return \"火墙\"; &#125; public void fight() &#123; System.out.println(\"稳稳的站在草地上\"); &#125;&#125; 1234567891011121314151617public class Function &#123; public void put(String name,int number) &#123; if(\"Bean\".equls(name)&#123; Bean bean=new Bean(); System.out.println(\"将\" + bean.getName() + \"放在\" + number + \"号草地上\"); bean.fight(); &#125;else if (\"Ice\".equls(name)) &#123; Ice ice= new Ice(); System.out.println(\"将\" + ice.getName() + \"放在\" + number + \"号草地上\"); ice.fight(); &#125;else if (\"Wall\".equls(name))&#123; Wall wall= new Wall(); System.out.println(\"将\" + wall.getName() + \"放在\" + number + \"号草地上\"); wall.fight(); &#125; &#125;&#125; 这样的话,功能实现了,但是代码的复用性和可维护性太差了. 所以我们的思路是:怎么创建对象能够进行统一的逻辑处理. 所以自然而然使用接口或抽象类. 这里我们使用接口. 123456789101112131415161718192021222324252627282930313233//Plant.javapublic interface Plant &#123; public String getName(); public void fight();&#125;//Bean.javapublic class Bean implements Plant&#123; public String getName() &#123; return \"绿逗\"; &#125; public void fight() &#123; System.out.println(\"发射一颗豆子\"); &#125;&#125;//Ice.javapublic class Ice implements Plant&#123; public String getName() &#123; return \"蓝冰\"; &#125; public void fight() &#123; System.out.println(\"发射一颗冰豆\"); &#125;&#125;//Wall.javapublic class Wall implements Plant&#123; public String getName() &#123; return \"火墙\"; &#125; public void fight() &#123; System.out.println(\"稳稳的站在草地上\"); &#125;&#125; 这样我们的function就可以统一创建对象进行逻辑处理,不需要单独做这些事情. 123456789101112131415//Function.javapublic class Function &#123; public void put(String name,int number)&#123; Plant plant = null; if(\"Bean\".equls(name)&#123; Plant plant =new Bean(); &#125;else if (\"Ice\".equls(name)) &#123; Plant plant= new Ice(); &#125;else if (\"Wall\".equls(name))&#123; Plant plant= new Wall(); &#125; System.out.println(\"将\" + plant.getName() + \"放在\" + number + \"号草地上\"); plant.fight(); &#125;&#125; 到这里似乎很可以了,但还远远不够. - 试想,如果我们游戏升级,又加入了几种植物,那么我的Function类的判断结构必须修改 - 如果这段代码经过改动用在其他地方,那么也需要修改.所以可维护性相当差. 这时,我们想到应该做封装,只需修改一次,到处生效. 简单工厂 这里我们引出简单工厂的概念:就是创建对象由工厂来创建,根据参数的不同创建不同的对象. 12345678910111213//SimpleFactory.java//这时的name为类名,使用反射技术public static Plant createPlantByClassName(String name) throws Exception &#123; return (Plant)Class.forName(name).newInstance();&#125;//Function.javapublic class Function &#123; public void put(String name,int number)&#123; Plant plant= SimpleFactory.createPlantByClassName(name); System.out.println(\"将\" + plant.getName() + \"放在\" + number + \"号草地上\"); plant.fight(); &#125;&#125; 这样,只要有新添加的植物,都可以由这个简单工厂生产出来.使用这个工厂,对于想要用到Plant对象的地方,不需要再关心对象的创建过程,直接用就好了,也不用关心创建过程的扩展和维护,这样可以降低耦合. 简单工厂 简单工厂对于一般的需求来说,已经能很好地实现了. 可是,现在又出现了新的需求 植物需要刻画地细致一些,比如,植物中有了头发,武器,果墙有了外壳.这样,我们需要创建头发,武器,外壳类,在植物中引用就可以了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//三个组件类public class Hair &#123; private String color; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125;&#125;public class Arms &#123; private String bulletType; public String getBulletType() &#123; return bulletType; &#125; public void setBulletType(String bulletType) &#123; this.bulletType = bulletType; &#125;&#125;public class Shell &#123; private Integer hardness; public Integer getHardness() &#123; return hardness; &#125; public void setHardness(Integer hardness) &#123; this.hardness = hardness; &#125;&#125;//三个植物类public class Bean implements Plant&#123; private Hair hair; private Arms arms; public String getName() &#123; return \"绿逗\"; &#125; public void fight() &#123; System.out.println(\"发射一颗豆子\"); &#125; public Hair getHair() &#123; return hair; &#125; public void setHair(Hair hair) &#123; this.hair = hair; &#125; public Arms getArms() &#123; return arms; &#125; public void setArms(Arms arms) &#123; this.arms = arms; &#125;&#125;public class Ice implements Plant&#123; private Hair hair; private Arms arms; public String getName() &#123; return \"蓝冰\"; &#125; public void fight() &#123; System.out.println(\"发射一颗冰豆\"); &#125; public Hair getHair() &#123; return hair; &#125; public void setHair(Hair hair) &#123; this.hair = hair; &#125; public Arms getArms() &#123; return arms; &#125; public void setArms(Arms arms) &#123; this.arms = arms; &#125;&#125;public class Wall implements Plant&#123; public Wall() &#123; Shell shell = new Shell(); shell.setHardness(5); this.shell = shell; &#125; private Shell shell; public String getName() &#123; return \"果墙\"; &#125; public void fight() &#123; System.out.println(\"稳稳的站在草地上\"); &#125; public Shell getShell() &#123; return shell; &#125; public void setShell(Shell shell) &#123; this.shell = shell; &#125;&#125; 这样,植物的创建过程就没有之前的那么简单了,一句创建对象的代码的反射就不能用了. 因为,每种植物加入了个性化的部分,并不是单纯实现接口中的方法. 而且,OOD(Object-Oriented Design)中有一个很重要的原则就是开闭原则:对扩展开放,对修改关闭. 虽然我们通常做不到完全对修改关闭,但是应该竟可能做极少修改. 工厂方法 因此,我们针对每种植物创建自己的工厂. 同样,刚才是创建每种植物时为了统一逻辑处理,抽象出了植物接口. 这时,我们也应该抽象出三个工厂的接口. 代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//public interface Factory &#123; public Plant createPlant();&#125;//public class BeanFactory implements Factory &#123; public Plant createPlant() &#123; Bean bean = new Bean(); Hair hair = new Hair(); hair.setColor(\"绿色\"); bean.setHair(hair); Arms arms = new Arms(); arms.setBulletType(\"普通的豆子\"); bean.setArms(arms); return bean; &#125;&#125;//public class IceFactory implements Factory &#123; public Plant createPlant() &#123; Ice ice = new Ice(); Hair hair = new Hair(); hair.setColor(\"蓝色\"); ice.setHair(hair); Arms arms = new Arms(); arms.setBulletType(\"冰冻的豆子\"); ice.setArms(arms); return ice; &#125;&#125;//public class WallFactory implements Factory &#123; public Plant createPlant() &#123; Wall wall = new Wall(); Shell shell = new Shell(); shell.setHardness(5); wall.setShell(shell); return wall; &#125;&#125;//public class FactoryBuilder &#123; public static Factory buildByClassName(String name) throws Exception &#123; return (Factory)Class.forName(name).newInstance(); &#125;&#125;//public class Function &#123; public void put(String name,int number) throws Exception &#123; Factory factory = FactoryBuilder.buildByClassName(name); Plant plant = factory.createPlant(); System.out.println(\"将\" + plant.getName() + \"放在\" + number + \"号草地上\"); plant.fight(); &#125;&#125; 至此,大功告成,如果修改某一植物的创建过程,只需修改各自的工厂 如果添加植物,只需创建植物类实现Plant,创建植物工厂类实现Factory,其他代码都不需要更改,尽最大可能实现开闭原则. 工厂方法 引用 https://class.imooc.com/sale/newjava?mc_marking=b9b1bf4f19e124900889941731e52a4b&amp;mc_channel=L2","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"明明白白理解java多态中upcasting downcasting的使用场景","slug":"明明白白理解java多态中upcasting-downcasting的使用场景","date":"2019-03-11T19:43:04.000Z","updated":"2020-02-15T18:19:07.000Z","comments":true,"path":"2019/03/12/明明白白理解java多态中upcasting-downcasting的使用场景/","link":"","permalink":"http://yoursite.com/2019/03/12/%E6%98%8E%E6%98%8E%E7%99%BD%E7%99%BD%E7%90%86%E8%A7%A3java%E5%A4%9A%E6%80%81%E4%B8%ADupcasting-downcasting%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"示例 upcasting(向上转型) 1234567891011121314//Upcastingtest.javaclass Upper&#123; public void f()&#123;System.out.println(\"Upper.f()\");&#125;&#125;class Down extends Upper&#123; public void f()&#123;System.out.println(\"Down.f()\");&#125;&#125;class Upcastingtest&#123; public static void Doit(Upper u)&#123; u.f(); &#125; public static void main(String[] args) &#123; Down down=new Down(); Doit(down); &#125; &#125; 执行结果 Down.f()","text":"示例 upcasting(向上转型) 1234567891011121314//Upcastingtest.javaclass Upper&#123; public void f()&#123;System.out.println(\"Upper.f()\");&#125;&#125;class Down extends Upper&#123; public void f()&#123;System.out.println(\"Down.f()\");&#125;&#125;class Upcastingtest&#123; public static void Doit(Upper u)&#123; u.f(); &#125; public static void main(String[] args) &#123; Down down=new Down(); Doit(down); &#125; &#125; 执行结果 Down.f() downcasting(向下转型) 12345678910111213141516171819202122232425262728293031323334class Employee&#123; public double salary; public void getSalary()&#123; System.out.println(\"my salary out\"); &#125;&#125;class Manager extends Employee&#123; public void speakLoudly()&#123; System.out.println(\"i take charge of this Department\"); &#125;&#125;class Worker extends Employee&#123; public void speakSilencely()&#123; System.out.println(\"i work hard \"); &#125;&#125;public class DownCastingDemo&#123; public static void main(String[] args) &#123; new DownCastingDemo().doSomething(new Manager()); &#125; public void doSomething(Employee e) &#123; if(e instanceof Manager)&#123; Manager m=(Manager)e; m.speakLoudly(); &#125; else if (e instanceof Worker) &#123; Worker w=(Worker) e; w.speakSilencely(); &#125;else&#123; e.getSalary(); &#125; &#125;&#125; 执行结果 i take charge of this Department 异同 相同 参数入口都是父类句柄 实际执行都是子类方法 不同 Upcasting 父类和子类都有该方法(即使用的是重写的方法) Downcasting 父类不具备该方法,即子类使用的是特有方法. 因此,如果使用的是子类特有方法,那么采用DownCasting;如果使用的子类重写的方法,则采用upCasting.","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"cap理论中的p的理解","slug":"cap理论中的p的理解","date":"2019-03-05T20:51:43.000Z","updated":"2020-02-15T18:19:52.000Z","comments":true,"path":"2019/03/06/cap理论中的p的理解/","link":"","permalink":"http://yoursite.com/2019/03/06/cap%E7%90%86%E8%AE%BA%E4%B8%AD%E7%9A%84p%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"概念 一致性（Consistency） 可用性（Availability） 分区容错性（Partition tolerance） 分布式系统中,以上三种性质不能同时满足","text":"概念 一致性（Consistency） 可用性（Availability） 分区容错性（Partition tolerance） 分布式系统中,以上三种性质不能同时满足 分区容错性 p:即partition tolerance,既然它是一个特性,那么它就有高低之分,比如我们形容一个系统的一致性很高,可用性很低等等,那么这个性质的高低是什么含义呢? ​ 我们说,一个系统非常的分区容忍,或者说分区容忍度很高,即代表即使有的分区因为某些原因宕掉,那么我们的系统依然可用. ​ 通常在当今的分布式系统比如hadoop,spark等等,这个特性是必须满足的.cap理论与其说三选二,实则是在C A中二选一. 参考 这个英文解释获赞很多 知乎","categories":[{"name":"分布式","slug":"分布式","permalink":"http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"cap","slug":"cap","permalink":"http://yoursite.com/tags/cap/"},{"name":"分布式理论","slug":"分布式理论","permalink":"http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/"}]},{"title":"反射","slug":"反射","date":"2018-03-11T13:04:26.000Z","updated":"2020-02-15T18:20:57.000Z","comments":true,"path":"2018/03/11/反射/","link":"","permalink":"http://yoursite.com/2018/03/11/%E5%8F%8D%E5%B0%84/","excerpt":"应用场景 编写通用性程度较高的代码,比如框架,通过配置文件动态获取.","text":"应用场景 编写通用性程度较高的代码,比如框架,通过配置文件动态获取. 原理 比如一个Person.java如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.hcb.reflect.test;public class Person &#123; public Person() &#123; super(); // TODO Auto-generated constructor stub &#125; public Person(String name, String sex) &#123; super(); this.name = name; this.sex = sex; &#125; private String name; private String sex; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public void eat()&#123; System.out.println(\"吃....\"); &#125; private void run()&#123; System.out.println(\"跑.....\"); &#125; public String sayHello(String name)&#123; return \"Hello \"+name; &#125; @Override public String toString() &#123; return \"Person [name=\" + name + \", sex=\" + sex + \"]\"; &#125;&#125; 编译后会生成一个person.class这个字节码文件,java中万物皆对象,java对这个字节码的管理和操作也是把它看做一个对象,那么它是谁的对象呢? 它是Class类的对象,Class类中定义了一系列的方法用于操作类对象.反射这种技术就是通过这些方法来实现的. ## 如何实现的呢 通常我们想使用一个对象都是通过 Person p = new Person(); 这种显示写死到代码里的. 如果我们想要创建的对象是之前未知的,临时从配置文件中得到的呢? 那么就需要这种形式 12345678//获取Person类对象 Class clazz = Class.forName(\"com.hcb.reflect.test.Person\"); //通过clazz得到无参的构造函数 Constructor c = clazz.getConstructor(); Person person = (Person) c.newInstance(); //或者得到有参的构造函数,因为方法的重载规则,这样肯定能确保得到确定的构造函数Constructor c = clazz.getConstructor(String.class,String.class); Person person = (Person) c.newInstance(\"张三\",\"男\"); 这样就可以愉快的动态使用对象了. reference https://www.zhihu.com/question/24304289/answer/147529485","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"关于servlet配置解决404的问题(idea)","slug":"关于servlet配置解决404的问题-idea","date":"2018-03-01T15:37:47.000Z","updated":"2020-02-15T18:24:04.000Z","comments":true,"path":"2018/03/01/关于servlet配置解决404的问题-idea/","link":"","permalink":"http://yoursite.com/2018/03/01/%E5%85%B3%E4%BA%8Eservlet%E9%85%8D%E7%BD%AE%E8%A7%A3%E5%86%B3404%E7%9A%84%E9%97%AE%E9%A2%98-idea/","excerpt":"idea中Java Web项目的访问路径问题","text":"idea中Java Web项目的访问路径问题 值得注意的地方 web.xml的配置 web.xml url-pattern的值是有反斜杠的. 表单中action配置的正确形式 action配置 注意:action的值是没有反斜杠的. 项目的路径配置 在没有配置项目名称时,action属性的值,有没有反斜杠都可以,所以容易产生误导. 正确方式是没有斜杠的. 还有一点需要注意的是:修改完上边的configuration后,redeploy是不行的,修改不起作用,需要rerun Tomcat. 因为服务器启动才会读取configuration.","categories":[],"tags":[{"name":"servlet","slug":"servlet","permalink":"http://yoursite.com/tags/servlet/"}]},{"title":"virtualbox同时实现上网和本地ping通(mac)","slug":"virtualbox同时实现上网和本地ping通-mac","date":"2018-01-05T08:55:36.000Z","updated":"2020-02-15T18:25:55.000Z","comments":true,"path":"2018/01/05/virtualbox同时实现上网和本地ping通-mac/","link":"","permalink":"http://yoursite.com/2018/01/05/virtualbox%E5%90%8C%E6%97%B6%E5%AE%9E%E7%8E%B0%E4%B8%8A%E7%BD%91%E5%92%8C%E6%9C%AC%E5%9C%B0ping%E9%80%9A-mac/","excerpt":"网络配置 虚拟机的网卡1通过nat连接外网,网卡2和主机互联","text":"网络配置 虚拟机的网卡1通过nat连接外网,网卡2和主机互联 网卡1配置 网卡二配置 网络状况 虚拟机(Ubuntu14)ip 虚拟机的ip情况 mac ip mac会多出一个网卡 互相ping mac ping虚拟机 虚拟机ping主机","categories":[{"name":"系统","slug":"系统","permalink":"http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"virtualbox","slug":"virtualbox","permalink":"http://yoursite.com/tags/virtualbox/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]}]}